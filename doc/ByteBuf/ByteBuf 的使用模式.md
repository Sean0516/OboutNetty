###  堆缓冲区

最常用的ByteBuf 模式是将数据存储在JVM 的堆空间中，这种模式被称为支持数组，它能在没有使用池化的情况下，提供快速的分配和释放。

### 直接缓冲区

直接缓冲区是另外一种 ByteBuf 模式。 我们期望用于对象创建的内存分配永远都来自堆中，但这并不是必须的------NIO 在JDK1.4 中引入的ByteBuffer 类允许JVM 实现通过本地调用来分配内存。这主要是为了避免每次调用本地IO 操作之前，将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）

直接缓冲区的内容将驻留在常规的会被垃圾收集的堆之外。 这也解释了为何直接缓冲区对于网络数据传输是理想的选择。如果你的数据包包含一个在堆上分配的缓冲区中。那么事实上，在通过套接字发生它之前，JVM 将会在内部把缓冲区复制到一个直接缓冲区中

直接缓冲区的主要缺点在于： 相对于基于堆的缓冲区，他们的分配和释放都比较昂贵。

### 复合缓冲区

复合缓冲区为多个ByteBuf 提供一个聚合视图。在这里你可以根据需要添加或删除ByteBuf 实例。 Netty 通过一个ByteBuf 子类----CompositeByteBuf  来实现这个模式。它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示

